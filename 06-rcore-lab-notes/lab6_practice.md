# 实验六：系统调用

## 实验题目

1. 原理：使用条件变量之后，分别从线程和操作系统的角度而言读取字符的系统调用是阻塞的还是非阻塞的？

   回答：对于线程是阻塞的，线程会等待直到字符输入；而对于操作系统是非阻塞的，阻塞的线程会被调度，未阻塞的线程继续运行

   参考答案：

   > 对于线程而言，是阻塞的，因为在等待有效输入之前线程都会暂停。但对于操作系统而言，等待输入的时间完全分配给了其他线程，所以对于操作系统来说是非阻塞的。

2. 设计：如果要让用户线程能够使用 `Vec` 等，需要做哪些工作？如果要让用户线程能够使用大于其栈大小的动态分配空间，需要做哪些工作？

   目前还不会

3. 实验：实现 `get_pid` 系统调用，使得用户线程可以获取自身的线程 ID。

   这个获取到的是线程 ID，应该是 `get_tid`，回头发一下 issue 去

   这个不难

4. 实验：将你在实验四（上）实现的 `fork` 改进成为 `sys_fork` 系统调用，使得该系统调用为父进程返回自身的线程 ID，而为子线程返回 0。

   其实 `sys_fork` 是克隆进程，`sys_clone` 才是线程，我实现了 `sys_clone`，这个也不算太难

5. 实验：将一个文件打包进用户镜像，并让一个用户进程读取它并打印其内容。需要实现 `sys_open`，将文件描述符加入线程的 `descriptor` 中，然后通过 `sys_read` 来读取。

   为了关闭文件，还要实现 `sys_close`吧，不然对文件太不负责任了

   明天再写
