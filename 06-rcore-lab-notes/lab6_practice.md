# 实验六：系统调用

## 实验题目

1. 原理：使用条件变量之后，分别从线程和操作系统的角度而言读取字符的系统调用是阻塞的还是非阻塞的？

   回答：对于线程是阻塞的，线程会等待直到字符输入；而对于操作系统是非阻塞的，阻塞的线程会被调度，未阻塞的线程继续运行

   参考答案：

   > 对于线程而言，是阻塞的，因为在等待有效输入之前线程都会暂停。但对于操作系统而言，等待输入的时间完全分配给了其他线程，所以对于操作系统来说是非阻塞的。

2. 设计：如果要让用户线程能够使用 `Vec` 等，需要做哪些工作？如果要让用户线程能够使用大于其栈大小的动态分配空间，需要做哪些工作？

   需要做的工作：在用户程序中实现内存分配算法？

   使用大于其栈大小的动态分配空间不会

3. 实验：实现 `get_pid` 系统调用，使得用户线程可以获取自身的线程 ID。

   这个获取到的是线程 ID，应该是 `get_tid`，回头发一下 issue 去

   这个不难

4. 实验：将你在实验四（上）实现的 `fork` 改进成为 `sys_fork` 系统调用，使得该系统调用为父进程返回自身的线程 ID，而为子线程返回 0。

   其实 `sys_fork` 是克隆进程，`sys_clone` 才是线程，我实现了 `sys_clone`，这个也不算太难

5. 实验：将一个文件打包进用户镜像，并让一个用户进程读取它并打印其内容。需要实现 `sys_open`，将文件描述符加入线程的 `descriptor` 中，然后通过 `sys_read` 来读取。

   为了关闭文件，还要实现 `sys_close`吧，不然对文件太不负责任了

   终于实现了！不算太难，就是有点麻烦

   简单说一下实现过程吧：

   1. 在操作系统和用户的 `syscall.rs` 里添加系统调用号和常量，这个很简单

   2. 在 `kernel/fs.rs` 里添加 `sys_openat` 和 `sys_close`，很简单

   3. 参考部分 rCore 的代码，添加 `Flags` 和 `check_and_clone_cstr`、`copy_from_user` 函数，用来将 `path` 变量从 `*const u8` 转换成 `&str`，这一步挺麻烦的

   4. 后面的实现就比较简单了，将文件添加到进程的 `descriptors` 中，返回 `fd`，`sys_open` 就完成了，`sys_close` 也只是将 `fd` 从 `descriptors` 中移出

6. 挑战实验：实现 `sys_pipe`，返回两个文件描述符，分别为一个管道的读和写端。用户线程调用完 `sys_pipe` 后调用 `sys_clone`，父线程写入管道，子线程可以读取。读取时尽量避免忙等待。

   这个不难，就是有点麻烦

   在简单写一下实现步骤吧，再说明一下，我不是一遍写代码一遍记录的，所以步骤可能不太准确（

   1. 按照惯例，在操作系统和用户的 `syscall.rs` 中添加系统调用号

   2. 惯例，在 `kernel/fs` 里添加 `sys_pipe2`

   3. 参考 `stdin.rs` 和 `stdout.rs` 还有 rCore 的代码，编写 `pipe.rs`，具体写法跟 `Stdin` 和 `Stdout` 很像，不再赘述

   4. 在 `sys_pipe2` 中，调用 `Pipe::create_pair` 创建管道，把管道添加到进程的 `descriptors` 中，然后类型转换来转换去，把管道的 `fd` 传给用户

   5. 编写用户程序，先创建管道再 clone，这个顺序不能反

   大概就是这样了～
