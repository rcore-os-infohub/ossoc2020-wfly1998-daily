# 实验三：虚实地址转换

1. 原理：在 `os/src/entry.asm` 中，`boot_page_table` 的意义是什么？当执行 `jal rust_main` 时，不考虑缓存，硬件通过哪些地址找到了 `rust_main` 的第一条指令？

   意义：`entry.asm` 中启动了 RISC-V 的页表机制，这时必须要有一个页表，`boot_page_table` 首先建立了一个大页页表（rCore 文档中称为“大页”，RISC-V文档中称为“吉页”），且并没有精细化，每个页表映射了 1G 的内存空间，为下一步的指令执行提供基础。

   纠正：建立页表机制后，跳转到 `rust_main` 不再使用 `jal` 指令了，因为此时 `rust_main` 函数的地址使用的是 64 位的虚拟地址，而 `jal` 指令的操作数不足 64 位，此时需要先将其地址存入寄存器，再使用 `jr` 指令跳转。

   链接器将 `rust_main` 的地址链接到以 `0xffffffff` 开始的虚拟地址上，软件通过符号表将 `rust_main` 函数的地址存入 t0 寄存器，使用 `jr` 指令跳转，硬件需要做的是查询页表第 510 项，将该虚拟地址映射到物理地址，再从物理地址中读取该函数并执行

   参考答案：

   > 1. `boot_page_table` 是一个用二进制表示的根页表，其中包含两个 1GB 大页，分别是将虚拟地址 `0x8000_0000` 至 `0xc000_0000` 映射到物理地址 `0x8000_0000` 至 `0xc000_0000`，以及将虚拟地址 `0xffff_ffff_8000_0000` 至 `0xffff_ffff_c000_0000` 映射到物理地址 `0x8000_0000` 至 `0xc000_0000`。
   >
   >    由于我们在 `linker.ld` 中指定了起始地址为 `0xffff_ffff_8020_0000`，操作系统执行文件会认为所有的符号都是在这个高地址上的。但是我们在硬件上只能将内核加载到 `0x8020_0000` 开始的内存空间上，此时的 `pc` 也会调转到这里。
   >
   >    为了让程序能够正确跳转至高地址的 `rust_main`，我们需要在 `entry.asm` 中先应用内核重映射，即将高地址映射到低地址。但我们不可能在替换页表的同时修改 `pc`，此时 `pc` 仍然处于低地址。所以，页表中的另一项（低地址的恒等映射）则保证程序替换页表后的短暂时间内，`pc` 仍然可以顺着低地址去执行内存中的指令。
   >
   >    *注：如果 `boot_page_table` 中不包含低地址恒等映射，程序可能仍然可以正常运行。这可能和硬件的缓存设计有关。但保险起见，应当保留这两个映射。*
   >
   > 2. 执行 `jal rust_main` 时，硬件需要加载 `rust_main` 对应的地址，大概是 `0xffff_ffff_802x_xxxx`。
   >    - 页表已经启用，硬件先从 `satp` 高位置读取内存映射模式，再从 `satp` 低位置读取根页表页号，即 `boot_page_table` 的物理页号
   >    - 对于 Sv39 模式，页号有三级共 27 位。对于 `rust_main` 而言，一级页号是其 [30:38] 位，即 510。硬件此时定位到根页表的第 510 项
   >    - 这一项的标志为 XWR，说明它指向一个大页而不是指向下一级页表；目标的页号为 `0x8_0000`，即物理地址 `0x8000_0000` 开始的区间；这一项的 V 位为 1，说明目标在内存中。因此，硬件寻址到页基址 + 页内偏移，即 `0x8000_0000 + 0x2x_xxxx`，找到 `rust_main`

   参考答案讲得更详细一些

2. 分析：为什么 `Mapping` 中的 `page_tables` 和 `mapped_pairs` 都保存了一些 `FrameTracker`？二者有何不同？

   我说怎么没见过有 `mapped_pairs` 呢，就没搜到...倒是有个 `allocated_pairs`

   回答：`page_tables` 保存的是进程的页表，`allocated_pairs` 保存的也是进程的页表...区别是，`allocated_pairs` 保存的是成功映射的，`page_tables` 保存的是所有的(?)

   参考答案：

   > 页表也是需要我们去分配页面来存储的。因此，`page_tables` 存放了所有页表所用到的页面，而 `mapped_pairs` 则存放了进程所用到的页面。

   我的答案完全错误，有空再好好理解一下

   **20200726补充**：看了下 `mapping.rs` 的 commit，五天前 `Mapping` 里终于加上 `mapped_pairs` 了，现在可以正经分析了

   回答：`page_tables` 存放了页表可能会用到的页面，`mapped_pairs` 存放了被映射过的页面

3. 分析：假设某进程需要虚拟地址 A 到物理地址 B 的映射，这需要操作系统来完成。那么操作系统在建立映射时有没有访问 B？如果有，它是怎么在还没有映射的情况下访问 B 的呢？

   回答：不需要访问吧。如果有，在内核中的话是线性映射的，直接减去 `0xffffffff00000000` 即可，不在内核中需要先申请，申请过程中得到 B 的地址就可以访问了。

   参考答案：

   > 建立映射不需要访问 B，而只需要操作页表即可。不过，通常程序都会需要操作系统建立映射的同时向页面中加载一些数据。此时，尽管 A→B 的映射尚不存在，因为我们将整个可用物理内存都建立了内核映射，所以操作系统仍然可以通过线性偏移量来访问到 B。

   参考答案没有分类讨论需要映射的地址是内核地址还是用户地址的问题

4. 实验：了解并实现时钟页面置换算法（或任何你感兴趣的算法），可以自行设计样例来比较性能

   改进的 Clock 算法

   - 思路
     - 减少修改页的缺页处理开销
   - 算法
     - 在页面中增加修改位，并在访问时进行相应修改
     - 缺页时，修改页面标志位，以跳过有修改的页面

   实现过程挺简单的，只有 `pop` 略麻烦一点，需要检查 PTE 的标志位，被访问过或者被修改过则去掉其标志位，如果访问位(ACCESS)和修改位(DIRTY)都为 0，则替换该页

   结果：FIFO 报出 `page_fault` 共 209 次，改进的 Clock 算法报出 `page_fault` 共 193 次

   （好像也没改进多少嘛

   另外再补充一下，编译的过程中我又遇到了之前见过的一种 error：

   > \`*mut memory::mapping::page_table_entry::PageTableEntry\` cannot be sent between threads safely

   下面提示需要

   > required because of the requirements on the impl of \`core::marker::Send\` for ......

   那么只需要为我们的 `ClockSwapper` 添加一行：

   ```rust
   unsafe impl Send for ClockSwapper {}
   ```

   error 就会消失了，虽然不知道是什么原理，但是这样就可以解决（
